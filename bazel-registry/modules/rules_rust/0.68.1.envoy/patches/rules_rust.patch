diff --git a/crate_universe/extensions.bzl b/crate_universe/extensions.bzl
index 3d4e646da..10ddb665e 100644
--- a/crate_universe/extensions.bzl
+++ b/crate_universe/extensions.bzl
@@ -635,7 +635,7 @@ def _generate_hub_and_spokes(
     )
 
     # The workspace root when one is explicitly provided.
-    nonhermetic_root_bazel_workspace_dir = module_ctx.path(Label("@@//:MODULE.bazel")).dirname
+    nonhermetic_root_bazel_workspace_dir = module_ctx.path(Label("@@//:BUILD")).dirname
 
     # If re-pinning is enabled, gather additional inputs for the generator
     kwargs = dict()
@@ -981,10 +981,13 @@ def _crate_impl(module_ctx):
     generator = _get_generator(module_ctx, host_triple)
 
     all_repos = []
+    all_repos_config = {}
+    generated_repos = []
 
     for mod in module_ctx.modules:
+        # Allow modules that only want to use_repo without defining their own crates
         if not mod.tags.from_cargo and not mod.tags.from_specs:
-            fail("`.from_cargo` or `.from_specs` are required. Please update {}".format(mod.name))
+            continue
 
         local_repos = []
         module_annotations = {}
@@ -1095,11 +1098,26 @@ def _crate_impl(module_ctx):
                 fail("Defined two crate universes with the same name in the same MODULE.bazel file (`{}`). Use the `name` tag to give them different names.".format(
                     cfg.name,
                 ))
+
             if cfg.name in all_repos:
-                fail("Defined two crate universes with the same name in different MODULE.bazel files (`{}`). Either give one a different name, or use `use_extension(isolate=True)`".format(
-                    cfg.name,
-                ))
-            all_repos.append(cfg.name)
+                # Check if pointing to same cargo files - if so, allow reuse
+                existing = all_repos_config.get(cfg.name)
+                cargo_lockfile_path = str(module_ctx.path(cfg.cargo_lockfile)) if cfg.cargo_lockfile else None
+                manifests_paths = tuple(sorted([str(module_ctx.path(m)) for m in cfg.manifests])) if hasattr(cfg, "manifests") and cfg.manifests else None
+
+                if not (existing and
+                    existing.get("cargo_lockfile") == cargo_lockfile_path and
+                    existing.get("manifests") == manifests_paths):
+                    fail("Defined two crate universes with the same name `{}` in different MODULE.bazel files pointing to different Cargo files. Either give one a different name, or use `use_extension(isolate=True)`".format(
+                        cfg.name,
+                    ))
+                # Same files - will skip generation in the loop below
+            else:
+                all_repos.append(cfg.name)
+                all_repos_config[cfg.name] = {
+                    "cargo_lockfile": str(module_ctx.path(cfg.cargo_lockfile)) if cfg.cargo_lockfile else None,
+                    "manifests": tuple(sorted([str(module_ctx.path(m)) for m in cfg.manifests])) if hasattr(cfg, "manifests") and cfg.manifests else None,
+                }
             local_repos.append(cfg.name)
 
         for repo in repo_specific_annotations:
@@ -1111,6 +1129,9 @@ def _crate_impl(module_ctx):
                 fail("Spec specified for repo {}, but the module defined repositories {}".format(repo, local_repos))
 
         for cfg in mod.tags.from_cargo + mod.tags.from_specs:
+            # Skip if already generated by another module (same files check passed above)
+            if cfg.name in generated_repos:
+                continue
             # Preload all external repositories. Calling `module_ctx.watch` will cause restarts of the implementation
             # function of the module extension when the file has changed.
             if cfg.cargo_lockfile:
@@ -1178,6 +1199,7 @@ def _crate_impl(module_ctx):
                 skip_cargo_lockfile_overwrite = cfg.skip_cargo_lockfile_overwrite,
                 strip_internal_dependencies_from_cargo_lockfile = cfg.strip_internal_dependencies_from_cargo_lockfile,
             )
+            generated_repos.append(cfg.name)
 
     metadata_kwargs = {}
     if bazel_features.external_deps.extension_metadata_has_reproducible:
diff --git a/rust/private/rustc.bzl b/rust/private/rustc.bzl
index a28ad50b7..7747a96ea 100644
--- a/rust/private/rustc.bzl
+++ b/rust/private/rustc.bzl
@@ -1164,7 +1164,7 @@ def construct_arguments(
 
     if toolchain.llvm_cov and ctx.configuration.coverage_enabled:
         # https://doc.rust-lang.org/rustc/instrument-coverage.html
-        rustc_flags.add("--codegen=instrument-coverage")
+        pass
 
     if toolchain._experimental_link_std_dylib:
         rustc_flags.add("--codegen=prefer-dynamic")
@@ -1727,7 +1727,7 @@ def rustc_compile_action(
             **crate_info_dict
         )
 
-    if crate_info.type in ["staticlib", "cdylib"]:
+    if crate_info.type in ["staticlib", "cdylib"] and not out_binary:
         # These rules are not supposed to be depended on by other rust targets, and
         # as such they shouldn't provide a CrateInfo. However, one may still want to
         # write a rust_test for them, so we provide the CrateInfo wrapped in a provider
